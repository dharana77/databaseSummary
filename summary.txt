인덱싱 탐색 삽입 삭제 속도
탐색을 속도가 빠르지만 삽입 삭제는 성능이 느릴 수 있다
그 이유는 인덱스는 데이터베이스의 테이블에 대한 검색 속도를 향상시켜주는 자료구조로
테이블의 특정 컬럼에 인덱스를 생성하면 해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간>에 데이터의 물리적 요소와 함께 저장된다.
즉 컬럼의 값과 물리적 주소를 (key, value) 의 한쌍으로 저장한다.

이러한 인덱스를 사용하면 당연하게도 테이블을 검색하는 속도와 성능이 향상된다.
그에 따라 시스템의 전반적인 부하를 줄일 수 있다.
인덱스에 의해 데이터들이 정렬된 형태를 갖고 기존엔 where 문으로 특정 데이를 찾기 위해 테>이블의 전를 조건과 비교해야하는 풀테이블 스캔 작업이 필요했지만 인덱스를 이용하면 데이터>들이 정렬되어 있기 때문에 조건에 맞는 데이터를 빠르게 찾을 수 있다.
또 Order by 문이나 Min/Max 같은 경우도 이미정렬이 되어 있기 때문에 빠르게 수행할 수 있다.

인덱스의 단점은 다음과 같을 수 있다.
인덱스를 관리하기 위한 추가작업이 필요
추가 저장 공간 필요
잘못 사용하는 경우 오히려 검색 성능 저하

또한 인덱스를 항상 정렬된 상탵로 유지해야 하기 때문에 인덱스가 적용된 컬럼에 삽입 삭제, >수정 작업을 수행하면 다음과 같은 추가 작업이 필요하다.
insert : 새로운 데이터에 대한 인덱스를 추가
delete : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행
update: 기존의 인덱스를 사용하지 않음 처리, 갱신도니 데이터에 대한 인덱스 추가

이와같이 인덱스 수정이 추가적으로 필요하기 때문에 데이터 수정이 잦은 경우 성능이 낮아짐.
또한 데이터의 인덱스를 제거하는 것이 아니라 '사용하지 않음'으로 처리하고 남겨두기 때문에 수정 작업이 많은경우 실제 데이터에 비해 인덱스가 과도하게 커지는 문제점 발생가능


인덱스의 자료구조로
인덱스는 여러자료구조를 이용해서 구현할 수 있는데, 대표적으로 해시테이블과 B+Tree가 있다.

1.해시테이블
key, value를 한쌍으로 데이터를 저장하는 자료구조
해시 충돌이라는 변수가 존재하지만 평균적으로 O(1)의 매우 빠른 시간만에 원하는 데이터 탐색가능하다
해시테이블을 이용한다면 인덱스는 (key, value) = (컬럼의 값, 데이터의 위치)로 구현하는데, 해시 테이블은 실제로 인덱스에서 잘사용되지 않는다.
그 이유는 해시테이블은 동호(=)연산에 최적화 되어있기 때문이다.
데이터베이스에서는 부등호 (<. >) 연산이 자주 사용되는데 해시 테이블 내의 데이터들은 정렬되어 있지 않으므로 특정 기준보다 크거나 작은 값을 빠른 시간 내에 찾을 수가 없다.

Q.이거 두개 밖에 없나 부족한 점이 뭔가 느껴짐
2. B+ Tree
기존의 B-Tree는 어느 한 데이터의 검색은 효율적이지만 모든 데이터를 한번 순회하는데에는 트리의 모든 노드를 방문해야 하므로 비효율적이다
이러한 B-Tree의 단점을 개선시킨 자료구조가 B+Tree이다.
B+Tree는 오직 leaf node에만 데이터를 저장하고 leaf node가 아닌 node에서는 자식 포인터만 저장한다.
그리고 leaf node끼리는 linked list로 되어있다.
B+Tree에서는 반드시 leaf node에만 데이터가 저장되기 때문에 중간 node에서 key를 올바르게 찾아가기 위해서 key가 중복될 수 있다.

이로인한 장점?
1. leaf node를 제외하고 데이터를 저장하지 않기 때문에 메모리를 더 확보할 수 있다. 따라서 하나의 node에 더 많은 포인터를 가질 수 있기 때문에 트리의 높이가 더 낮아지므로 검색속도를 높일 수 있다.
(?)
2. full scan을 하는 경우 B+tree는 leaf node에만 데이터가 저장되어 있고, leaf node끼리 linked list로 연결되어 있기 때문에
선형 시간이 소모된다. 반면 B-Tree는 모든 node를 확인해야 한다.

반면 B-Tree의 경우 최상의 경우 특정 key를 루트 노드에서 찾을 수 있지만 B+Tree의 경우 반드시 특정 key에 접근하기 위해서 leaf node까지 내려가야 하는 단점이 있다.

인덱스에서 B-Tree 대신 주로 B+Tree를 주로 사용하는 이유는 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생할 수 있는데
B+Tree의 linked list를 이용하면 순차 검색을 효율적으로 할 수 있다.

B+Tree의 검색 과정은 B-Tree와 동일하다. 반면 B+Tree의 삽입과 삭제 과정은 약간의 차이가 있다.
기본적으로 B+Tree의 삽입과 삭제는 항상 leaf node에서 일어난다.

삽입 삭제 O(1) ? O(log n)?
B-Tree는 O(log n)이고 B+-Tree는 리프노드에서만 발생하기 때문에 O(1)일 것 같은데 계산해보기
(과정에 따른)
https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Plus-Tree
